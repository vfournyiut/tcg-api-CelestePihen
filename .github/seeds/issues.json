[
  {
    "title": "1. Schéma Prisma - Deck et DeckCard (1 pts)",
    "body": "## Objectif\n\nCompléter le schéma Prisma pour gérer les decks de cartes des utilisateurs.\n\n## Structure des tables\n\nVoici la structure complète de la base de données après avoir ajouté les modèles Deck et DeckCard :\n\n```mermaid\nerDiagram\n    User ||--o{ Deck : owns\n    Deck ||--o{ DeckCard : contains\n    Card ||--o{ DeckCard : \"is in\"\n\n    User {\n        int id PK\n        string username\n        string email\n        string password\n        datetime createdAt\n        datetime updatedAt\n    }\n\n    Card {\n        int id PK\n        string name\n        int hp\n        int attack\n        PokemonType type\n        int pokedexNumber\n        string imgUrl\n        datetime createdAt\n        datetime updatedAt\n    }\n\n    Deck {\n        int id PK\n        string name\n        int userId FK\n        datetime createdAt\n        datetime updatedAt\n    }\n\n    DeckCard {\n        int id PK\n        int deckId FK\n        int cardId FK\n    }\n```\n\n**Relations**\n\n- Un **User** peut avoir plusieurs **Decks** (1:N)\n- Un **Deck** appartient à un **User** (N:1)\n- Un **Deck** contient plusieurs **Cards** via **DeckCard** (N:M)\n- Une **Card** peut être dans plusieurs **Decks** via **DeckCard** (N:M)\n\n**Schéma de base fourni**\n\nLes modèles `User` et `Card` sont déjà fournis dans le schéma Prisma.\n\n## Modèles à créer\n\n**Modèle `Deck`**\n\nUn deck appartient à un utilisateur et contient 10 cartes.\n\n**Modèle `DeckCard`**\n\nTable de jonction pour la relation Many-to-Many entre Deck et Card.\n\n## Exigences\n\n- [ ] Modèle `Deck` créé suivant les spécifications\n- [ ] Modèle `DeckCard` créé suivant les spécifications\n- [ ] Les IDs sont auto-incrémentés\n- [ ] Migration crée avec succès (`npm run db:migrate`)\n- [ ] 4 tables présentes en base (`npm run db:studio`)\n\n## Comment tester\n\nUtilisez **Prisma Studio** pour vérifier la structure :\n\n```bash\nnpm run db:studio\n```\n\nVérifiez que les 4 tables sont présentes : User, Card, Deck, DeckCard",
    "labels": ["Base de données"],
    "points": 1,
    "status": "À faire"
  },
  {
    "title": "2. Script de seed (1 pts)",
    "body": "## Script de seed\n\nModifiez le script de seed (`prisma/seed.ts`) pour créer un deck de démarrage pour chaque utilisateur de test :\n\n**Fonctionnalité attendue** :\n\n- Créer un deck nommé \"Starter Deck\" pour l'utilisateur **red**\n- Créer un deck nommé \"Starter Deck\" pour l'utilisateur **blue**\n- Chaque deck doit contenir **10 cartes aléatoires** parmi les cartes disponibles en base\n\n> **Conseil** : Utilisez une fonction pour sélectionner aléatoirement 10 cartes parmi toutes les cartes créées.\n\n**Exigences**\n\n- [ ] Seed exécuté avec succès (`npm run db:seed`)\n- [ ] 1 deck \"Starter Deck\" créé pour l'utilisateur red (10 cartes aléatoires)\n- [ ] 1 deck \"Starter Deck\" créé pour l'utilisateur blue (10 cartes aléatoires)\n- [ ] Les decks contiennent bien 10 cartes chacun\n\n**Comment tester**\n\nUtilisez **Prisma Studio** pour vérifier visuellement les données créées en base :\n\n```bash\nnpm run db:studio\n```\n\nVérifiez que :\n\n- Les 4 tables sont présentes (User, Card, Deck, DeckCard)\n- 2 utilisateurs existent (red et blue)\n- 2 decks \"Starter Deck\" sont créés (un pour chaque utilisateur)\n- Chaque deck contient exactement 10 cartes via la table DeckCard\n- Les cartes sont correctement reliées aux decks",
    "labels": ["Base de données"],
    "points": 1,
    "status": "À faire"
  },
  {
    "title": "3. Authentification et sécurisation (2 pts)",
    "body": "## Authentification et sécurisation\n\nMettre en place un système d'authentification JWT qui sera utilisé pour sécuriser les endpoints de l'API.\n\n### Endpoint `POST /api/auth/sign-up`\n\nCréer un nouveau compte utilisateur avec authentification JWT.\n\nValide les données, vérifie l'unicité de l'email, hash le mot de passe et génère un token JWT (validité : 7 jours).\n\n**Exemple de payload** :\n\n```json\n{\n  \"email\": \"user@example.com\",\n  \"username\": \"username\",\n  \"password\": \"password123\"\n}\n```\n\n**Exigences**\n\n- [ ] Inscription réussie avec données valides (email, username, password) → `201`\n- [ ] Retourne un token JWT valide\n- [ ] Retourne les infos utilisateur (sans le mot de passe)\n- [ ] Le mot de passe est hashé en base\n- [ ] Erreur si email déjà utilisé → `409`\n- [ ] Erreur si données manquantes/invalides → `400`\n- [ ] Erreur serveur → `500`\n\n> **Bibliothèques** : Utilisez `jsonwebtoken` et `bcryptjs`. Le secret JWT est dans `env.JWT_SECRET`.\n\n### Endpoint `POST /api/auth/sign-in`\n\nSe connecter avec un compte existant et recevoir un token JWT.\n\nRécupère l'utilisateur par email, vérifie le mot de passe et génère un token JWT.\n\n**Exemple de payload** :\n\n```json\n{\n  \"email\": \"user@example.com\",\n  \"password\": \"password123\"\n}\n```\n\n**Exigences**\n\n- [ ] Connexion réussie avec identifiants corrects → `200`\n- [ ] Retourne un token JWT valide\n- [ ] Retourne les infos utilisateur (sans le mot de passe)\n- [ ] Erreur si email inexistant → `401`\n- [ ] Erreur si mot de passe incorrect → `401`\n- [ ] Erreur si données manquantes → `400`\n- [ ] Erreur serveur → `500`\n\n### Middleware d'authentification\n\nCréer un middleware qui protège les routes nécessitant une authentification.\n\nLe middleware doit :\n\n1. Extraire le token du header `Authorization: Bearer <token>`\n2. Vérifier et décoder le token\n3. Injecter les données utilisateur (`userId` et `email`) dans `req.user` si valide\n4. Retourner une erreur 401 si invalide ou absent\n\n**Exigences**\n\n- [ ] Requête acceptée avec token valide dans le header `Authorization: Bearer <token>`\n- [ ] `req.user` contient `userId` (number) et `email` (string) extraits du token\n- [ ] Requête rejetée si aucun token fourni → `401`\n- [ ] Requête rejetée si token invalide → `401`\n- [ ] Requête rejetée si token expiré → `401`\n\n**Comment tester**\n\nUtilisez la **collection Bruno** fournie dans le dossier `bruno/` pour tester tous les endpoints de l'API.\n\nLes utilisateurs de test sont documentés dans `bruno/Auth/README.md` :\n\n- Email : `red@tcg.com` / Password : `password123`\n- Email : `blue@tcg.com` / Password : `password123`",
    "labels": ["API"],
    "points": 2,
    "status": "À faire"
  },
  {
    "title": "4. API Cards (1 pts)",
    "body": "## API Cards\n\n### Endpoint `GET /api/cards`\n\nCréer un endpoint public de consultation du catalogue de cartes.\n\nRetourne la liste complète des cartes Pokemon triées par numéro de Pokédex.\n\n**Exigences**\n\n- [ ] `GET /api/cards` retourne toute la liste des cartes\n- [ ] Les cartes sont triées par `pokedexNumber` croissant\n- [ ] Toutes les propriétés des cartes sont présentes (id, name, hp, attack, type, etc.)\n- [ ] Code de statut `200` en cas de succès\n- [ ] Code de statut `500` en cas d'erreur serveur\n\n> **Conseils** : Gérez les erreurs avec un try/catch\n\n**Comment tester**\n\nUtilisez la **collection Bruno** fournie dans le dossier `bruno/` : **Cards/** : Consultation du catalogue",
    "labels": ["API"],
    "points": 1,
    "status": "À faire"
  },
  {
    "title": "5. API Decks - CRUD complet (3 pts)",
    "body": "## API Decks\n\nImplémenter un CRUD complet pour la gestion des decks de cartes.\nUn deck doit contenir **exactement 10 cartes valides** (existantes en base).\n\n> **Important** : Tous les endpoints Decks doivent être protégés avec le middleware d'authentification créé dans la section Authentification. Les decks doivent être associés à l'utilisateur connecté via `req.user.userId`.\n\n### Endpoint `POST /api/decks`\n\nCréer un nouveau deck pour l'utilisateur authentifié.\n\nLe deck est automatiquement associé à l'utilisateur via `req.user.userId` extrait du token JWT.\n\n**Exemple de payload** :\n\n```json\n{\n  \"name\": \"My Starter Deck\",\n  \"cards\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n}\n```\n\n**Exigences**\n\n- [ ] Création réussie avec 10 cartes valides → `201`\n- [ ] Le deck est associé au `userId` de l'utilisateur connecté\n- [ ] Le deck créé contient bien les 10 cartes demandées\n- [ ] Requête rejetée sans token → `401`\n- [ ] Erreur si pas 10 cartes → `400`\n- [ ] Erreur si IDs de cartes invalides/inexistants → `400`\n- [ ] Erreur si nom manquant → `400`\n- [ ] Erreur serveur → `500`\n\n### Endpoint `GET /api/decks/mine`\n\nLister tous les decks de l'utilisateur authentifié avec leurs cartes.\n\nFiltre automatiquement par `req.user.userId` pour ne retourner que les decks de l'utilisateur connecté.\n\n**Exigences**\n\n- [ ] Retourne uniquement les decks de l'utilisateur connecté → `200`\n- [ ] Chaque deck contient ses cartes associées\n- [ ] Liste vide si aucun deck → `200`\n- [ ] Requête rejetée sans token → `401`\n- [ ] Un utilisateur ne peut pas voir les decks d'un autre utilisateur\n- [ ] Erreur serveur → `500`\n\n### Endpoint `GET /api/decks/:id`\n\nConsulter un deck spécifique avec ses cartes.\n\nVérifie que le deck appartient à l'utilisateur authentifié.\n\n**Exigences**\n\n- [ ] Retourne le deck demandé avec ses cartes → `200`\n- [ ] Requête rejetée sans token → `401`\n- [ ] Erreur si le deck n'appartient pas à l'utilisateur → `403` ou `404`\n- [ ] Erreur si ID inexistant → `404`\n- [ ] Erreur serveur → `500`\n\n### Endpoint `PATCH /api/decks/:id`\n\nModifier le nom et/ou les cartes du deck.\n\n> **Conseils** : Si les cartes sont modifiées, dans ce cas le plus simple est de supprimer les anciennes associations et d'en créer de nouvelles.\n\n**Exemple de payload** :\n\n```json\n{\n  \"name\": \"Updated Deck Name\",\n  \"cards\": [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n}\n```\n\n**Exigences**\n\n- [ ] Modification réussie → `200`\n- [ ] Les anciennes cartes sont bien remplacées par les nouvelles\n- [ ] Requête rejetée sans token → `401`\n- [ ] Erreur si le deck n'appartient pas à l'utilisateur → `403` ou `404`\n- [ ] Erreur si moins/plus de 10 cartes → `400`\n- [ ] Erreur si IDs de cartes invalides → `400`\n- [ ] Erreur si deck inexistant → `404`\n- [ ] Erreur serveur → `500`\n\n### Endpoint `DELETE /api/decks/:id`\n\nSupprimer définitivement un deck.\n\n**Exigences**\n\n- [ ] Suppression réussie → `200`\n- [ ] Le deck n'existe plus après suppression\n- [ ] Les DeckCards associés sont supprimés\n- [ ] Requête rejetée sans token → `401`\n- [ ] Erreur si le deck n'appartient pas à l'utilisateur → `403` ou `404`\n- [ ] Erreur si deck inexistant → `404`\n- [ ] Erreur serveur → `500`\n\n**Comment tester**\n\nUtilisez la **collection Bruno** fournie dans le dossier `bruno/` : **Decks/** : CRUD complet des decks\n\n> **Note** : Pensez à récupérer le token JWT après connexion et à l'utiliser dans les requêtes protégées via l'onglet \"Auth\" de Bruno.",
    "labels": ["API"],
    "points": 3,
    "status": "À faire"
  },
  {
    "title": "6. Tests unitaires (2,5 pts)",
    "body": "## Tests\n\nImplémenter des tests unitaires avec Vitest pour garantir la fiabilité et la maintenabilité du code.\n\nLes tests doivent couvrir l'ensemble des fonctionnalités de l'API : authentification, gestion des cartes et des decks.\n\n> **Note** : La configuration Vitest (`vitest.config.ts`) et le setup des mocks Prisma (`tests/vitest.setup.ts`) sont déjà fournis dans le projet. Le mock `prismaMock` est disponible pour être utilisé dans les tests.\n\n**Exigences**\n\n- [ ] Fichier `tests/auth.test.ts` teste les endpoints d'authentification\n- [ ] Fichier `tests/card.test.ts` teste les endpoint de consultation des cartes\n- [ ] Fichier `tests/deck.test.ts` teste le CRUD complet des decks\n- [ ] Fichier `tests/auth.middleware.test.ts` créé et teste l'authentification JWT\n- [ ] Coverage de 100% atteint (branches, fonctions, lignes, statements)\n- [ ] Tous les tests passent avec succès (`npm run test`)\n\n**Comment tester**\n\n```bash\n# Run tests in watch mode (auto-reload)\nnpm test\n\n# Run tests once\nnpm run test:run\n\n# Run tests with UI\nnpm run test:ui\n\n# Run tests with coverage report\nnpm run test:coverage\n```",
    "labels": ["API"],
    "points": 2.5,
    "status": "À faire"
  },
  {
    "title": "7. Documentation avec JSDoc (0,5 pts)",
    "body": "## Documentation avec JSDoc\n\nDocumenter le code source avec JSDoc pour améliorer la lisibilité et la maintenabilité du projet.\n\n**Exigences**\n\n- [ ] Toutes les fonctions (routes et middlewares) documentées\n- [ ] Description claire du rôle de chaque fonction\n- [ ] Paramètres de requête documentés\n- [ ] Valeurs de retour documentées\n- [ ] Cas d'erreur documentés avec `@throws`",
    "labels": ["API"],
    "points": 0.5,
    "status": "À faire"
  },
  {
    "title": "8. Documentation Swagger (1 pts)",
    "body": "## Documentation Swagger\n\nDocumenter l'API avec OpenAPI/Swagger.\n\n**Structure attendue**\n\n- **Configuration principale** (`swagger.config.yml`) : Infos générales, schémas, sécurité\n- **Documentation par module** (`auth.doc.yml`, `card.doc.yml`, `deck.doc.yml`) : Endpoints\n- **Agrégation** (`index.ts`) : Fusion des documentations\n\n**Exigences**\n\n- [ ] UI Swagger accessible sur `/api-docs` et fonctionnelle\n- [ ] Configuration principale (`swagger.config.yml`) avec schémas réutilisables (User, Card, Deck, Error)\n- [ ] Fichiers de documentation par module créés (auth, card, deck) et agrégés\n- [ ] Tous les endpoints documentés avec descriptions, paramètres, corps de requête et réponses\n- [ ] Authentification Bearer JWT configurée avec bouton \"Authorize\" fonctionnel\n- [ ] Routes protégées marquées avec `security: [bearerAuth]`\n- [ ] Tous les endpoints testables depuis l'UI avec exemples corrects",
    "labels": ["API"],
    "points": 1,
    "status": "À faire"
  },
  {
    "title": "9. Authentification Socket.io (1 pts)",
    "body": "## Authentification Socket.io\n\nMettre en place un système d'authentification pour les connexions WebSocket.\n\nLes connexions Socket.io doivent être authentifiées avec le token JWT envoyé dans `socket.handshake.auth.token`.\n\n**Fonctionnalités attendues** :\n\n- Authentification via JWT pour toutes les connexions WebSocket\n- Injection des informations utilisateur (userId, email) dans le socket après authentification réussie\n\n**Exigences**\n\n- [ ] Connexion refusée sans token\n- [ ] Connexion refusée avec token invalide\n- [ ] Connexion acceptée avec token JWT valide\n- [ ] Les informations utilisateur (userId, email) sont disponibles dans le socket après authentification\n\n**Comment tester**\n\nUtilisez le **client HTML** fourni pour tester les fonctionnalités Socket.io en temps réel.\n\nLe client est accessible directement à l'URL du serveur :\n\n```bash\n# Démarrer le serveur\nnpm run dev\n\n# Ouvrir deux navigateurs (ou onglets en navigation privée) sur :\nhttp://localhost:3001\n```\n\nLe client HTML vous permet de :\n\n- Vous connecter avec un token JWT (récupéré via Bruno ou l'API)\n- Créer ou rejoindre une room\n- Tester toutes les actions de jeu (piocher, jouer, attaquer)\n- Visualiser l'état du jeu en temps réel pour les deux joueurs\n\n> **Astuce** : Utilisez deux fenêtres de navigation privée pour simuler deux joueurs différents avec les comptes `red` et `blue`.",
    "labels": ["Socket"],
    "points": 1,
    "status": "À faire"
  },
  {
    "title": "10. Système de Matchmaking (3 pts)",
    "body": "## Système de Matchmaking\n\nImplémenter le système de création et de jonction de rooms pour le matchmaking entre joueurs.\n\n**Fonctionnalités attendues** :\n\n- Créer une room d'attente avec un deck\n- Lister les rooms disponibles\n- Rejoindre une room existante\n- Démarrer automatiquement la partie quand 2 joueurs sont présents\n\n### Événement `createRoom`\n\nCréer une room d'attente avec un deck.\n\nLe joueur qui crée la room devient le host et attend qu'un second joueur le rejoigne.\n\n**Paramètres attendus** :\n\n```json\n{\n  \"deckId\": 1\n}\n```\n\n**Événements émis** :\n\n- `roomCreated` : Confirmation envoyée au créateur avec les infos de la room\n- `roomsListUpdated` : Broadcast à tous les clients avec la liste mise à jour\n\n**Exigences**\n\n- [ ] Création réussie avec un deck valide (10 cartes) appartenant à l'utilisateur\n- [ ] Le deck est vérifié en base de données (appartenance et validité)\n- [ ] Erreur si le deck n'appartient pas à l'utilisateur\n- [ ] Erreur si le deck est invalide (≠ 10 cartes)\n- [ ] Le socket rejoint une room Socket.io\n- [ ] Événement `roomCreated` envoyé au créateur\n- [ ] Événement `roomsListUpdated` broadcast à tous les clients\n\n### Événement `getRooms`\n\nObtenir la liste des rooms disponibles pour le matchmaking.\n\nRetourne uniquement les rooms en attente d'un second joueur.\n\n**Exigences**\n\n- [ ] Retourne la liste des rooms disponibles\n- [ ] Les rooms complètes (parties en cours) ne sont pas listées\n- [ ] Chaque room contient les informations du host (username, etc.)\n\n### Événement `joinRoom`\n\nRejoindre une room existante et démarrer la partie.\n\n**Paramètres attendus** :\n\n```json\n{\n  \"roomId\": 1,\n  \"deckId\": 2\n}\n```\n\n**Événements émis** :\n\n- `gameStarted` : Envoyé aux deux joueurs avec l'état initial\n- `roomsListUpdated` : Broadcast à tous les clients (room retirée de la liste)\n\n**Exigences**\n\n- [ ] Jonction réussie avec un deck valide appartenant à l'utilisateur\n- [ ] Le deck est vérifié en base de données (appartenance et validité)\n- [ ] Erreur si la room n'existe pas\n- [ ] Erreur si la room est déjà complète\n- [ ] La partie démarre automatiquement quand le second joueur rejoint\n- [ ] Événement `gameStarted` envoyé aux deux joueurs\n- [ ] Chaque joueur reçoit un état différent (sa main visible, celle de l'adversaire cachée)\n- [ ] La room disparaît de la liste des rooms disponibles\n- [ ] Événement `roomsListUpdated` broadcast à tous les clients\n\n**Comment tester**\n\nUtilisez le **client HTML** fourni en ouvrant deux navigateurs/onglets en navigation privée sur http://localhost:3001",
    "labels": ["Socket"],
    "points": 3,
    "status": "À faire"
  },
  {
    "title": "11. Système de Jeu (4 pts)",
    "body": "## Système de Jeu\n\nImplémenter la logique de jeu en temps réel avec gestion des tours et des actions.\n\n**Règles du jeu** :\n\n- **Main** : 5 cartes maximum\n- **Terrain** : 1 carte active maximum par joueur\n- **Combat** : Dégâts basés sur l'Attaque de la carte, avec multiplicateur x2 si faiblesse de type\n- **HP** : Diminuent à chaque attaque, la carte est KO si HP ≤ 0\n- **Score** : +1 point par carte adverse vaincue\n- **Victoire** : Premier joueur à atteindre 3 points\n- **Tours** : Le créateur de la room commence, puis alternance après chaque attaque\n\n**Calcul des dégâts** : Utilisez les fonctions fournies dans `utils/rules.util.ts` pour le calcul des dégâts et la gestion des faiblesses de type.\n\n**Fonctionnalités attendues** :\n\n- Piocher des cartes (maximum 5 en main)\n- Jouer une carte sur le terrain (1 carte active maximum)\n- Attaquer la carte adverse avec sa carte active\n- Système de tours alternés\n- Calcul des dégâts avec multiplicateur de faiblesse (x2)\n- Système de score (points par carte adverse vaincue)\n- Détection de victoire (premier à 3 points)\n\n**Exigences de sécurité** :\n\n- Toutes les actions sont validées côté serveur\n- La main de l'adversaire n'est jamais exposée\n- Le deck de l'adversaire n'est jamais exposé\n- Impossible de jouer hors de son tour (vérifié pour chaque action)\n\n### Événement `drawCards`\n\nPiocher des cartes depuis son deck jusqu'à avoir 5 cartes en main.\n\n**Événements émis** :\n\n- `gameStateUpdated` : Envoyé aux deux joueurs avec l'état mis à jour\n\n**Exigences**\n\n- [ ] Pioche jusqu'à 5 cartes maximum\n- [ ] Erreur si ce n'est pas le tour du joueur\n- [ ] Événement `gameStateUpdated` envoyé aux deux joueurs\n- [ ] Chaque joueur reçoit une vue adaptée (main adverse cachée)\n\n### Événement `playCard`\n\nJouer une carte de sa main sur le terrain.\n\n**Paramètres attendus** :\n\n```json\n{\n  \"cardIndex\": 0\n}\n```\n\n**Événements émis** :\n\n- `gameStateUpdated` : Envoyé aux deux joueurs avec l'état mis à jour\n\n**Exigences**\n\n- [ ] La carte est retirée de la main et devient la carte active\n- [ ] Une seule carte active à la fois sur le terrain\n- [ ] Erreur si l'index de carte est invalide\n- [ ] Erreur si ce n'est pas le tour du joueur\n- [ ] Événement `gameStateUpdated` envoyé aux deux joueurs\n\n### Événement `attack`\n\nAttaquer la carte adverse avec sa carte active.\n\n**Événements émis** :\n\n- `gameStateUpdated` : Envoyé aux deux joueurs si la partie continue\n- `gameEnded` : Envoyé aux deux joueurs si victoire détectée\n\n**Exigences**\n\n- [ ] Attaque réussie si les deux joueurs ont une carte active\n- [ ] Erreur si le joueur n'a pas de carte active\n- [ ] Erreur si l'adversaire n'a pas de carte active\n- [ ] Erreur si ce n'est pas le tour du joueur\n- [ ] Dégâts calculés correctement avec `utils/rules.util.ts`\n- [ ] Multiplicateur de faiblesse appliqué (x2 dégâts)\n- [ ] HP de la carte adverse diminuent\n- [ ] Score augmente si la carte adverse est KO (HP ≤ 0)\n- [ ] Le tour change après l'attaque\n- [ ] Victoire détectée quand un joueur atteint 3 points\n- [ ] Événement `gameEnded` envoyé si victoire\n\n### Événement `endTurn`\n\nTerminer son tour et passer la main au joueur adverse.\n\n**Paramètres attendus** :\n\n```json\n{\n  \"roomId\": 1\n}\n```\n\n**Événements émis** :\n\n- `gameStateUpdated` : Envoyé aux deux joueurs avec l'état mis à jour\n\n**Exigences**\n\n- [ ] Le tour passe au joueur adverse\n- [ ] Erreur si ce n'est pas le tour du joueur\n- [ ] Événement `gameStateUpdated` envoyé aux deux joueurs\n- [ ] Le joueur adverse reçoit un message indiquant que c'est son tour\n- [ ] L'état du jeu contient l'information sur le joueur actuel (`currentPlayerSocketId`)\n\n**Comment tester**\n\nUtilisez le **client HTML** fourni en ouvrant deux navigateurs/onglets en navigation privée sur http://localhost:3001\n\nToute la logique de jeu doit être exécutée côté serveur, il est responsable de :\n\n- Valider toutes les actions des joueurs\n- Gérer l'état complet du jeu\n- Calculer les résultats des combats\n- Ne jamais exposer d'informations cachées (main/deck de l'adversaire)",
    "labels": ["Socket"],
    "points": 4,
    "status": "À faire"
  }
]
